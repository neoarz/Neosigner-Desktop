name: Build macOS App

on:
  push:
    tags:
      - 'v*'
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:  # Allow manual trigger

permissions:
  contents: write # Required for creating releases
  packages: read

jobs:
  build:
    runs-on: macos-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'
      
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyinstaller pillow
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          
          # Verify tkinter is available (it's part of standard library)
          python -c "import tkinter; print('Tkinter is available, version:', tkinter.TkVersion)"
      
      - name: Clone zsign if needed
        run: |
          if [ ! -d "zsign" ]; then
            git clone https://github.com/zhlynn/zsign.git
          fi
      
      - name: Install build dependencies
        run: |
          brew update
          brew install pkg-config openssl@1.1 minizip
          brew install libimobiledevice ideviceinstaller create-dmg
          
          # Ensure dependencies have the right permissions
          echo "Checking for libimobiledevice binaries..."
          for bin in idevice_id ideviceinfo idevicename ideviceinstaller; do
            BINARY_PATH=$(which $bin 2>/dev/null || echo "")
            if [ -n "$BINARY_PATH" ]; then
              echo "Found $bin at $BINARY_PATH"
              if [ ! -x "$BINARY_PATH" ]; then
                echo "Making $BINARY_PATH executable..."
                sudo chmod +x "$BINARY_PATH"
              fi
            else
              echo "Warning: $bin not found"
            fi
          done
      
      - name: Build zsign
        run: |
          cd zsign/build/macos
          make clean && make
          cd ../../..
          
          # Print where the binary is
          echo "Looking for zsign binary..."
          find zsign -name zsign -type f -exec ls -la {} \;
          
          # Create bin directory and copy zsign
          mkdir -p bin
          # Check if zsign is in zsign/bin
          if [ -f "zsign/bin/zsign" ]; then
            cp zsign/bin/zsign bin/
          # Or if it's directly in the build directory
          elif [ -f "zsign/build/macos/zsign" ]; then
            cp zsign/build/macos/zsign bin/
          else
            echo "Error: zsign binary not found!"
            exit 1
          fi
          chmod +x bin/zsign
          
          # Verify that zsign works
          bin/zsign -v
      
      - name: Create app bundle structure
        run: |
          # First, make sure our resources directory exists with proper permissions
          sudo rm -rf resources/bin || true
          mkdir -p resources || true
          sudo mkdir -p resources/bin || mkdir -p resources/bin
          sudo chown -R $(whoami) resources || true
          sudo chmod -R 755 resources || chmod -R 755 resources
          
          # Copy zsign to resources/bin
          cp bin/zsign resources/bin/
          chmod +x resources/bin/zsign
          
          # Copy ideviceinstaller and dependencies with sudo if needed
          IDEVICEINSTALLER_PATH=$(which ideviceinstaller)
          if [ -n "$IDEVICEINSTALLER_PATH" ]; then
            echo "Copying ideviceinstaller from: $IDEVICEINSTALLER_PATH"
            sudo cp "$IDEVICEINSTALLER_PATH" resources/bin/ || cp "$IDEVICEINSTALLER_PATH" resources/bin/
            sudo chmod +x resources/bin/ideviceinstaller
            echo "Copied ideviceinstaller to resources/bin/"
          else
            echo "Warning: ideviceinstaller not found"
          fi
          
          # Copy libimobiledevice utilities and dependencies
          for util in idevice_id ideviceinfo idevicename ideviceinstaller; do
            UTIL_PATH=$(which $util)
            if [ -n "$UTIL_PATH" ]; then
              echo "Copying $util from: $UTIL_PATH"
              sudo cp "$UTIL_PATH" resources/bin/ || cp "$UTIL_PATH" resources/bin/
              sudo chmod +x resources/bin/$util || chmod +x resources/bin/$util
              echo "Copied $util to resources/bin/"
              
              # Get the destination path for the binary
              DEST_BIN="resources/bin/$(basename "$UTIL_PATH")"
              
              # Find all dylib dependencies
              otool -L "$UTIL_PATH" | grep -v "/System" | grep -v "/usr/lib" | awk '{print $1}' | while read -r lib; do
                if [[ "$lib" == *"/"* ]] && [[ -f "$lib" ]]; then
                  lib_base=$(basename "$lib")
                  if [[ ! -f "resources/bin/$lib_base" ]]; then
                    echo "Copying $lib to resources/bin/$lib_base"
                    sudo cp "$lib" "resources/bin/$lib_base" || cp "$lib" "resources/bin/$lib_base" || echo "Failed to copy $lib"
                    sudo chmod +x "resources/bin/$lib_base" || chmod +x "resources/bin/$lib_base"
                    
                    # Fix the rpath in the binary
                    sudo install_name_tool -change "$lib" "@executable_path/$lib_base" "$DEST_BIN" 2>/dev/null || install_name_tool -change "$lib" "@executable_path/$lib_base" "$DEST_BIN" 2>/dev/null || echo "Failed to change path for $lib in $DEST_BIN"
                    
                    # Recursively copy dependencies of this library too
                    otool -L "$lib" | grep -v "/System" | grep -v "/usr/lib" | awk '{print $1}' | while read -r sublib; do
                      if [[ "$sublib" == *"/"* ]] && [[ -f "$sublib" ]] && [[ "$sublib" != "$lib" ]]; then
                        sublib_base=$(basename "$sublib")
                        if [[ ! -f "resources/bin/$sublib_base" ]]; then
                          echo "Copying sub-dependency $sublib to resources/bin/$sublib_base"
                          sudo cp "$sublib" "resources/bin/$sublib_base" || cp "$sublib" "resources/bin/$sublib_base" || echo "Failed to copy $sublib"
                          sudo chmod +x "resources/bin/$sublib_base" || chmod +x "resources/bin/$sublib_base"
                        fi
                      fi
                    done
                  fi
                fi
              done
            fi
          done
          
          # Fix up all binaries to use local copies of dylibs
          for bin_file in resources/bin/*; do
            if [ -f "$bin_file" ] && [ -x "$bin_file" ]; then
              echo "Fixing dependencies for $bin_file"
              otool -L "$bin_file" | grep -v "/System" | grep -v "/usr/lib" | awk '{print $1}' | while read -r lib; do
                if [[ "$lib" == *"/"* ]]; then
                  lib_base=$(basename "$lib")
                  # Only fix if we have a local copy
                  if [[ -f "resources/bin/$lib_base" ]]; then
                    echo "Fixing rpath: $lib -> @executable_path/$lib_base in $bin_file"
                    sudo install_name_tool -change "$lib" "@executable_path/$lib_base" "$bin_file" 2>/dev/null || install_name_tool -change "$lib" "@executable_path/$lib_base" "$bin_file" 2>/dev/null || echo "Failed to change path for $lib in $bin_file"
                  else
                    echo "Warning: dependency $lib not found locally for $bin_file"
                  fi
                fi
              done
            fi
          done
          
          # List the resources/bin directory to verify
          echo "Contents of resources/bin:"
          ls -la resources/bin/
          
          # Make sure all files in resources/bin are executable
          echo "Making sure all files in resources/bin are executable..."
          find resources/bin/ -type f -exec sudo chmod +x {} \; || find resources/bin/ -type f -exec chmod +x {} \;
          
          # List again to verify permissions
          echo "Contents of resources/bin after fixing permissions:"
          ls -la resources/bin/
          
          # Check file type and dependencies
          for bin_file in resources/bin/*; do
            if [ -f "$bin_file" ] && [ -x "$bin_file" ]; then
              echo "File type of $bin_file:"
              file "$bin_file"
              echo "Dependencies of $bin_file:"
              otool -L "$bin_file" | head -n 20
            fi
          done
      
      - name: Create app launcher
        run: |
          cat > app_launcher.py << 'EOF'
          #!/usr/bin/env python3
          import os
          import sys
          import subprocess
          import tkinter as tk
          import stat
          from tkinter import messagebox
          
          # Get the application path
          if getattr(sys, 'frozen', False):
              # Running as a bundled executable
              application_path = os.path.dirname(sys.executable)
              # For Mac app bundles, resources should be in various possible locations
              # List all possible bin paths in order of preference
              possible_bin_paths = [
                  os.path.join(application_path, 'bin'),                              # /Contents/MacOS/bin
                  os.path.join(os.path.dirname(application_path), 'Resources', 'bin'), # /Contents/Resources/bin
                  os.path.join(application_path, 'resources', 'bin'),                 # /Contents/MacOS/resources/bin
                  os.path.join(os.path.dirname(application_path), 'Resources', 'resources', 'bin'), # /Contents/Resources/resources/bin
                  os.path.join(application_path, 'Frameworks', 'bin'),                 # /Contents/Frameworks/bin
              ]
              
              # Find the first valid bin path
              bin_path = None
              for path in possible_bin_paths:
                  if os.path.exists(path) and os.path.isdir(path):
                      bin_path = path
                      break
          else:
              # Running as a script
              application_path = os.path.dirname(os.path.abspath(__file__))
              bin_path = os.path.join(application_path, 'resources', 'bin')
          
          print(f"Application path: {application_path}")
          print(f"Selected bin path: {bin_path}")
          
          # Function to fix permissions
          def fix_permissions(directory):
              if not os.path.exists(directory):
                  print(f"Directory does not exist: {directory}")
                  return
                  
              print(f"Fixing permissions in {directory}")
              try:
                  # Fix permissions on all files in the directory
                  for filename in os.listdir(directory):
                      filepath = os.path.join(directory, filename)
                      if os.path.isfile(filepath):
                          current_permissions = os.stat(filepath).st_mode
                          # Add executable permission
                          new_permissions = current_permissions | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH
                          os.chmod(filepath, new_permissions)
                          print(f"Fixed permissions for {filepath}: {oct(new_permissions)}")
              except Exception as e:
                  print(f"Error fixing permissions: {e}")
          
          # Add bin directory to PATH
          if bin_path and os.path.exists(bin_path):
              # Fix permissions
              fix_permissions(bin_path)
              
              # Prepend bin path to PATH environment variable
              os.environ['PATH'] = f"{bin_path}:{os.environ.get('PATH', '')}"
              print(f"Added {bin_path} to PATH")
              
              # Set DYLD_LIBRARY_PATH to help find dependencies
              if os.environ.get('DYLD_LIBRARY_PATH'):
                  os.environ['DYLD_LIBRARY_PATH'] = f"{bin_path}:{os.environ.get('DYLD_LIBRARY_PATH', '')}"
              else:
                  os.environ['DYLD_LIBRARY_PATH'] = bin_path
              
              # Debug: List bin directory contents
              print("Bin directory contents:")
              try:
                  for f in os.listdir(bin_path):
                      file_path = os.path.join(bin_path, f)
                      is_exec = os.access(file_path, os.X_OK)
                      print(f"  {f} - Executable: {is_exec}")
              except Exception as e:
                  print(f"Error while accessing bin directory: {e}")
          else:
              print(f"Warning: No valid bin path found!")
              for path in possible_bin_paths:
                  print(f"  Checked: {path} - Exists: {os.path.exists(path)}")
              
              # Try to give more diagnostic info
              if getattr(sys, 'frozen', False):
                  print("App bundle structure:")
                  if os.path.exists(os.path.join(os.path.dirname(application_path), 'Resources')):
                      resources_dir = os.path.join(os.path.dirname(application_path), 'Resources')
                      print(f"Resources directory exists: {resources_dir}")
                      try:
                          print(f"Resources contents: {os.listdir(resources_dir)}")
                      except Exception as e:
                          print(f"Error listing Resources: {e}")
          
          # Import zsign_gui here to ensure PATH is set first
          try:
              import zsign_gui
          except ImportError as e:
              print(f"Error importing zsign_gui: {e}")
              tk.Tk().withdraw()
              messagebox.showerror("Error", f"Failed to import zsign_gui: {e}")
              sys.exit(1)
          
          # Check if zsign and ideviceinstaller are available
          try:
              # Check zsign
              zsign_path = None
              if bin_path:
                  zsign_path = os.path.join(bin_path, "zsign")
                  if os.path.exists(zsign_path):
                      print(f"Found zsign at: {zsign_path}")
                      # Make sure it's executable
                      if not os.access(zsign_path, os.X_OK):
                          print(f"Making zsign executable: {zsign_path}")
                          os.chmod(zsign_path, 0o755)
                  else:
                      print(f"zsign not found at expected path: {zsign_path}")
              
              # Try to run zsign to verify it works
              try:
                  result = subprocess.run([zsign_path, "-v"] if zsign_path else ["zsign", "-v"], 
                                          stdout=subprocess.PIPE, 
                                          stderr=subprocess.PIPE, 
                                          text=True,
                                          env=os.environ)
                  print(f"zsign version check result: {result.returncode}")
                  print(f"zsign output: {result.stdout}")
                  if result.stderr:
                      print(f"zsign stderr: {result.stderr}")
              except Exception as e:
                  print(f"Error running zsign: {e}")
                  
              # Check ideviceinstaller
              ideviceinstaller_path = None
              if bin_path:
                  ideviceinstaller_path = os.path.join(bin_path, "ideviceinstaller")
                  if os.path.exists(ideviceinstaller_path):
                      print(f"Found ideviceinstaller at: {ideviceinstaller_path}")
                      # Make it executable if needed
                      if not os.access(ideviceinstaller_path, os.X_OK):
                          print(f"Making ideviceinstaller executable: {ideviceinstaller_path}")
                          os.chmod(ideviceinstaller_path, 0o755)
                  else:
                      print(f"ideviceinstaller not found at expected path: {ideviceinstaller_path}")
              
              # Try to check ideviceinstaller version
              try:
                  result = subprocess.run([ideviceinstaller_path, "--version"] if ideviceinstaller_path else ["ideviceinstaller", "--version"], 
                                          stdout=subprocess.PIPE, 
                                          stderr=subprocess.PIPE, 
                                          text=True,
                                          env=os.environ)
                  print(f"ideviceinstaller version check result: {result.returncode}")
                  print(f"ideviceinstaller output: {result.stdout}")
                  if result.stderr:
                      print(f"ideviceinstaller stderr: {result.stderr}")
              except Exception as e:
                  print(f"Error checking ideviceinstaller: {e}")
          except Exception as e:
              print(f"Error checking tools: {e}")
          
          # Launch the GUI
          if __name__ == "__main__":
              try:
                  root = tk.Tk()
                  app = zsign_gui.ZsignGUI(root)
                  root.mainloop()
              except Exception as e:
                  print(f"Error launching app: {e}")
                  if 'root' in locals() and root.winfo_exists():
                      messagebox.showerror("Error", f"Failed to launch app: {e}")
                  else:
                      tk_root = tk.Tk()
                      tk_root.withdraw()
                      messagebox.showerror("Error", f"Failed to launch app: {e}")
                  sys.exit(1)
          EOF
      
      - name: Create macOS app icon from existing image
        run: |
          # Create the iconset directory
          mkdir -p app_icon.iconset
          
          # Use Python and Pillow to process the existing image
          python3 - << 'EOF'
          from PIL import Image
          import os
          import math
          
          # Create iconset directory if it doesn't exist
          os.makedirs("app_icon.iconset", exist_ok=True)
          
          # Icon sizes needed for macOS
          sizes = [16, 32, 64, 128, 256, 512, 1024]
          
          try:
              # Load the source image
              source_img = Image.open("assets/Icon.png")
              
              # Function to create circular mask
              def create_circular_mask(size):
                  img = Image.new('RGBA', (size, size), (0, 0, 0, 0))
                  mask = Image.new('L', (size, size), 0)
                  
                  # Draw a circle on the mask
                  import ImageDraw
                  draw = ImageDraw.Draw(mask)
                  draw.ellipse((0, 0, size, size), fill=255)
                  
                  return mask
              
              # Process image for each size
              for size in sizes:
                  # Resize the image while maintaining aspect ratio
                  img = source_img.copy()
                  img = img.resize((size, size), Image.LANCZOS)
                  
                  # Try to make it circular (macOS style) using a mask
                  try:
                      # For older Pillow versions
                      mask = Image.new('L', (size, size), 0)
                      import ImageDraw
                      draw = ImageDraw.Draw(mask)
                      draw.ellipse((0, 0, size, size), fill=255)
                      
                      # Create a blank RGBA image
                      circular_img = Image.new('RGBA', (size, size), (0, 0, 0, 0))
                      
                      # Paste the resized image using the circle mask
                      circular_img.paste(img, (0, 0), mask)
                      img = circular_img
                  except:
                      # Newer Pillow versions may handle this differently
                      # If the above fails, we'll use the square image as fallback
                      pass
                  
                  # Save icon in various sizes
                  img.save(f"app_icon.iconset/icon_{size}x{size}.png")
                  
                  # Save @2x versions where applicable
                  if size * 2 <= 1024:
                      img_2x = source_img.copy()
                      img_2x = img_2x.resize((size * 2, size * 2), Image.LANCZOS)
                      img_2x.save(f"app_icon.iconset/icon_{size}x{size}@2x.png")
              
              print("App icons generated successfully!")
          except Exception as e:
              print(f"Error processing app icon: {e}")
              # Create a simple fallback icon if we couldn't process the image
              for size in sizes:
                  img = Image.new('RGBA', (size, size), color=(52, 152, 219))
                  img.save(f"app_icon.iconset/icon_{size}x{size}.png")
                  
                  if size * 2 <= 1024:
                      img_2x = Image.new('RGBA', (size * 2, size * 2), color=(52, 152, 219))
                      img_2x.save(f"app_icon.iconset/icon_{size}x{size}@2x.png")
              
              print("Created fallback icons due to error with source image")
          EOF
          
          # Use iconutil to convert the iconset to icns (macOS only)
          iconutil -c icns app_icon.iconset
          
          # Verify the icon was created
          ls -la app_icon.icns
      
      - name: Create simplified PyInstaller spec file
        run: |
          cat > NeoSigner.spec << EOF
          # -*- mode: python ; coding: utf-8 -*-

          block_cipher = None

          # Collect all binary files from resources/bin
          bin_files = []
          import os
          
          # Make sure resources/bin exists
          if not os.path.exists('resources/bin'):
              os.makedirs('resources/bin', exist_ok=True)
              
          # Create direct bin dir for zsign
          if not os.path.exists('bin'):
              os.makedirs('bin', exist_ok=True)
          
          # Make sure zsign is in both places
          if os.path.exists('resources/bin/zsign'):
              os.system('cp resources/bin/zsign bin/zsign 2>/dev/null || true')
              os.system('chmod +x bin/zsign 2>/dev/null || true')
          elif os.path.exists('bin/zsign'):
              os.system('cp bin/zsign resources/bin/zsign 2>/dev/null || true')
              os.system('chmod +x resources/bin/zsign 2>/dev/null || true')
          
          # Create list of binary files for PyInstaller
          for file in os.listdir('resources/bin'):
              bin_files.append(('resources/bin/' + file, 'bin/' + file))
          
          # Special case for zsign
          if os.path.exists('bin/zsign'):
              bin_files.append(('bin/zsign', 'bin/zsign'))

          a = Analysis(
              ['app_launcher.py'],
              pathex=[],
              binaries=bin_files,  # Include all binary files
              datas=[
                  ('zsign_gui.py', '.'),
                  ('assets/Icon.png', 'assets'),
              ],
              hiddenimports=['tkinter', 'tkinter.ttk', 'tkinter.filedialog', 'tkinter.messagebox', 'tkinter.scrolledtext'],
              hookspath=[],
              hooksconfig={},
              runtime_hooks=[],
              excludes=[],
              win_no_prefer_redirects=False,
              win_private_assemblies=False,
              cipher=block_cipher,
              noarchive=False,
          )
          pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

          exe = EXE(
              pyz,
              a.scripts,
              [],
              exclude_binaries=True,
              name='NeoSigner',
              debug=False,
              bootloader_ignore_signals=False,
              strip=False,
              upx=True,
              console=False,  # Set to False to hide terminal window
              disable_windowed_traceback=False,
              argv_emulation=True,
              target_arch=None,
              codesign_identity=None,
              entitlements_file=None,
              icon='app_icon.icns',
          )
          coll = COLLECT(
              exe,
              a.binaries,
              a.zipfiles,
              a.datas,
              strip=False,
              upx=True,
              upx_exclude=[],
              name='NeoSigner',
          )
          app = BUNDLE(
              coll,
              name='NeoSigner.app',
              bundle_identifier='com.neoarz.neosigner',
              icon='app_icon.icns',
              info_plist={
                  'CFBundleShortVersionString': '1.0.0',
                  'CFBundleName': 'NeoSigner',
                  'CFBundleDisplayName': 'NeoSigner',
                  'CFBundleExecutable': 'NeoSigner',
                  'CFBundleVersion': '1.0.0',
                  'NSHighResolutionCapable': True,
                  'NSRequiresAquaSystemAppearance': False,
                  'LSApplicationCategoryType': 'public.app-category.developer-tools',
                  'NSHumanReadableCopyright': 'Copyright Â© 2023',
                  'LSMinimumSystemVersion': '10.14.0'
              },
          )
          EOF
      
      - name: Build macOS app
        run: |
          pyinstaller --clean NeoSigner.spec
      
      - name: Verify app structure
        run: |
          echo "Checking app structure..."
          find dist/NeoSigner.app -type d | sort
          
          echo "Looking for zsign in the app bundle..."
          find dist/NeoSigner.app -name zsign -type f | xargs ls -la || echo "zsign not found in app bundle"
          
          echo "Looking for ideviceinstaller in the app bundle..."
          find dist/NeoSigner.app -name ideviceinstaller -type f | xargs ls -la || echo "ideviceinstaller not found in app bundle"
          
          echo "Making sure binaries are executable..."
          find dist/NeoSigner.app -name zsign -type f -exec chmod +x {} \; || true
          find dist/NeoSigner.app -name ideviceinstaller -type f -exec chmod +x {} \; || true
          
          echo "Checking bin directories for key binaries..."
          find dist/NeoSigner.app -path "*/bin" -type d | while read -r bin_dir; do
            echo "Contents of $bin_dir:"
            ls -la "$bin_dir" || echo "Failed to list $bin_dir"
            
            # Check specific binaries
            for binary in zsign ideviceinstaller; do
              if [ -f "$bin_dir/$binary" ]; then
                echo "Found $binary in $bin_dir"
                chmod +x "$bin_dir/$binary"
                file "$bin_dir/$binary"
                
                # Check if it runs
                "$bin_dir/$binary" -v 2>&1 || echo "Failed to run $binary"
              fi
            done
            
            # Check dependencies of each binary
            echo "Checking dependencies in $bin_dir..."
            find "$bin_dir" -type f -perm +111 | while read -r bin_file; do
              echo "Dependencies for $bin_file:"
              otool -L "$bin_file" | head -n 10 || echo "Failed to check dependencies for $bin_file"
            done
          done
          
          echo "Checking resources directory..."
          ls -la dist/NeoSigner.app/Contents/Resources/bin 2>/dev/null || echo "Resources/bin not found"
          ls -la dist/NeoSigner.app/Contents/MacOS/bin 2>/dev/null || echo "MacOS/bin not found"
          ls -la dist/NeoSigner.app/Contents/Frameworks/bin 2>/dev/null || echo "Frameworks/bin not found"
          
          echo "Contents of app bundle:"
          find dist/NeoSigner.app -type f -name "*.py" | sort
          
          echo "Checking if app launcher is properly included..."
          cat dist/NeoSigner.app/Contents/MacOS/NeoSigner || echo "Could not find app launcher"
      
      - name: Get version from tag
        id: get_version
        run: |
          if [[ "$GITHUB_REF" == refs/tags/v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          else
            VERSION="dev-$(date +'%Y%m%d%H%M%S')"
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          fi
      
      - name: Create DMG disk image
        run: |
          # Create a simple background image for the DMG
          python3 - << 'EOF'
          from PIL import Image, ImageDraw, ImageFont
          
          # Create a nice gradient background
          width, height = 600, 400
          background = Image.new('RGBA', (width, height), color=(240, 240, 240, 255))
          
          # Add a subtle gradient
          draw = ImageDraw.Draw(background)
          for y in range(height):
              # Create a vertical gradient from light blue to white
              color = (52, 152, 219, int(255 * (1 - y / height)))
              draw.line([(0, y), (width, y)], fill=color)
          
          # Add text
          try:
              # Try to use a font, falling back as needed
              font_size = 32
              try:
                  # Try system font first
                  font = ImageFont.truetype("Arial Bold", font_size)
              except:
                  # Fall back to default
                  font = ImageFont.load_default()
                  
              draw.text((width/2, height/2 - 50), "NeoSigner", font=font, fill=(40, 40, 40), anchor="mm")
              
              font_size = 16
              try:
                  font_small = ImageFont.truetype("Arial", font_size)
              except:
                  font_small = font
                  
              draw.text((width/2, height/2 + 20), "Drag the application to the Applications folder", 
                      font=font_small, fill=(80, 80, 80), anchor="mm")
          except Exception as e:
              print(f"Error adding text to background: {e}")
          
          # Save the background
          background.save("dmg_background.png")
          print("Created DMG background image")
          EOF
          
          # Create a temporary directory for DMG contents
          mkdir -p dmg_contents
          
          # Copy the app to the temporary directory
          cp -R dist/NeoSigner.app dmg_contents/
          
          # Create a symbolic link to /Applications
          ln -s /Applications dmg_contents/Applications
          
          # Create the DMG
          VERSION=${{ steps.get_version.outputs.VERSION }}
          create-dmg \
            --volname "NeoSigner" \
            --volicon "app_icon.icns" \
            --background "dmg_background.png" \
            --window-pos 200 120 \
            --window-size 600 400 \
            --icon-size 100 \
            --icon "NeoSigner.app" 150 190 \
            --icon "Applications" 450 190 \
            --hide-extension "NeoSigner.app" \
            --app-drop-link 450 190 \
            "NeoSigner-$VERSION.dmg" \
            "dmg_contents/"
          
          # Verify the DMG was created
          ls -la NeoSigner-$VERSION.dmg
      
      - name: Upload app as artifact
        uses: actions/upload-artifact@v4
        with:
          name: NeoSigner-${{ steps.get_version.outputs.VERSION }}
          path: NeoSigner-${{ steps.get_version.outputs.VERSION }}.dmg
      
      - name: Create Release and Upload Asset
        if: startsWith(github.ref, 'refs/tags/v')
        uses: softprops/action-gh-release@v2
        with:
          files: NeoSigner-${{ steps.get_version.outputs.VERSION }}.dmg
          draft: false
          prerelease: false 
